{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { createVNode as _createVNode } from \"vue\";\nimport { useProvideKeysState, TreeContext } from './contextTypes';\nimport { getDragChildrenKeys, parseCheckedKeys, conductExpandParent, calcSelectedKeys, calcDropPosition, arrAdd, arrDel, posToArr } from './util';\nimport { flattenTreeData, convertTreeToData, convertDataToEntities, convertNodePropsToEventData, getTreeNodeProps, fillFieldNames } from './utils/treeUtil';\nimport NodeList, { MOTION_KEY, MotionEntity } from './NodeList';\nimport { conductCheck } from './utils/conductUtil';\nimport DropIndicator from './DropIndicator';\nimport { computed, defineComponent, onUnmounted, reactive, shallowRef, watch, watchEffect, nextTick, toRaw } from 'vue';\nimport initDefaultProps from '../_util/props-util/initDefaultProps';\nimport { treeProps } from './props';\nimport { warning } from '../vc-util/warning';\nimport KeyCode from '../_util/KeyCode';\nimport classNames from '../_util/classNames';\nimport pickAttrs from '../_util/pickAttrs';\nimport useMaxLevel from './useMaxLevel';\nconst MAX_RETRY_TIMES = 10;\nexport default defineComponent({\n  compatConfig: {\n    MODE: 3\n  },\n  name: 'Tree',\n  inheritAttrs: false,\n  props: initDefaultProps(treeProps(), {\n    prefixCls: 'vc-tree',\n    showLine: false,\n    showIcon: true,\n    selectable: true,\n    multiple: false,\n    checkable: false,\n    disabled: false,\n    checkStrictly: false,\n    draggable: false,\n    expandAction: false,\n    defaultExpandParent: true,\n    autoExpandParent: false,\n    defaultExpandAll: false,\n    defaultExpandedKeys: [],\n    defaultCheckedKeys: [],\n    defaultSelectedKeys: [],\n    dropIndicatorRender: DropIndicator,\n    allowDrop: () => true\n  }),\n  setup(props, _ref) {\n    let {\n      attrs,\n      slots,\n      expose\n    } = _ref;\n    const destroyed = shallowRef(false);\n    let delayedDragEnterLogic = {};\n    const indent = shallowRef();\n    const selectedKeys = shallowRef([]);\n    const checkedKeys = shallowRef([]);\n    const halfCheckedKeys = shallowRef([]);\n    const loadedKeys = shallowRef([]);\n    const loadingKeys = shallowRef([]);\n    const expandedKeys = shallowRef([]);\n    const loadingRetryTimes = {};\n    const dragState = reactive({\n      draggingNodeKey: null,\n      dragChildrenKeys: [],\n      // dropTargetKey is the key of abstract-drop-node\n      // the abstract-drop-node is the real drop node when drag and drop\n      // not the DOM drag over node\n      dropTargetKey: null,\n      dropPosition: null,\n      dropContainerKey: null,\n      dropLevelOffset: null,\n      dropTargetPos: null,\n      dropAllowed: true,\n      // the abstract-drag-over-node\n      // if mouse is on the bottom of top dom node or no the top of the bottom dom node\n      // abstract-drag-over-node is the top node\n      dragOverNodeKey: null\n    });\n    const treeData = shallowRef([]);\n    watch([() => props.treeData, () => props.children], () => {\n      treeData.value = props.treeData !== undefined ? toRaw(props.treeData).slice() : convertTreeToData(toRaw(props.children));\n    }, {\n      immediate: true,\n      deep: true\n    });\n    const keyEntities = shallowRef({});\n    const focused = shallowRef(false);\n    const activeKey = shallowRef(null);\n    const listChanging = shallowRef(false);\n    const fieldNames = computed(() => fillFieldNames(props.fieldNames));\n    const listRef = shallowRef();\n    let dragStartMousePosition = null;\n    let dragNode = null;\n    let currentMouseOverDroppableNodeKey = null;\n    const treeNodeRequiredProps = computed(() => {\n      return {\n        expandedKeysSet: expandedKeysSet.value,\n        selectedKeysSet: selectedKeysSet.value,\n        loadedKeysSet: loadedKeysSet.value,\n        loadingKeysSet: loadingKeysSet.value,\n        checkedKeysSet: checkedKeysSet.value,\n        halfCheckedKeysSet: halfCheckedKeysSet.value,\n        dragOverNodeKey: dragState.dragOverNodeKey,\n        dropPosition: dragState.dropPosition,\n        keyEntities: keyEntities.value\n      };\n    });\n    const expandedKeysSet = computed(() => {\n      return new Set(expandedKeys.value);\n    });\n    const selectedKeysSet = computed(() => {\n      return new Set(selectedKeys.value);\n    });\n    const loadedKeysSet = computed(() => {\n      return new Set(loadedKeys.value);\n    });\n    const loadingKeysSet = computed(() => {\n      return new Set(loadingKeys.value);\n    });\n    const checkedKeysSet = computed(() => {\n      return new Set(checkedKeys.value);\n    });\n    const halfCheckedKeysSet = computed(() => {\n      return new Set(halfCheckedKeys.value);\n    });\n    watchEffect(() => {\n      if (treeData.value) {\n        const entitiesMap = convertDataToEntities(treeData.value, {\n          fieldNames: fieldNames.value\n        });\n        keyEntities.value = _extends({\n          [MOTION_KEY]: MotionEntity\n        }, entitiesMap.keyEntities);\n      }\n    });\n    let init = false; // 处理 defaultXxxx api, 仅仅首次有效\n    watch([() => props.expandedKeys, () => props.autoExpandParent, keyEntities],\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    (_ref2, _ref3) => {\n      let [_newKeys, newAutoExpandParent] = _ref2;\n      let [_oldKeys, oldAutoExpandParent] = _ref3;\n      let keys = expandedKeys.value;\n      // ================ expandedKeys =================\n      if (props.expandedKeys !== undefined || init && newAutoExpandParent !== oldAutoExpandParent) {\n        keys = props.autoExpandParent || !init && props.defaultExpandParent ? conductExpandParent(props.expandedKeys, keyEntities.value) : props.expandedKeys;\n      } else if (!init && props.defaultExpandAll) {\n        const cloneKeyEntities = _extends({}, keyEntities.value);\n        delete cloneKeyEntities[MOTION_KEY];\n        keys = Object.keys(cloneKeyEntities).map(key => cloneKeyEntities[key].key);\n      } else if (!init && props.defaultExpandedKeys) {\n        keys = props.autoExpandParent || props.defaultExpandParent ? conductExpandParent(props.defaultExpandedKeys, keyEntities.value) : props.defaultExpandedKeys;\n      }\n      if (keys) {\n        expandedKeys.value = keys;\n      }\n      init = true;\n    }, {\n      immediate: true\n    });\n    // ================ flattenNodes =================\n    const flattenNodes = shallowRef([]);\n    watchEffect(() => {\n      flattenNodes.value = flattenTreeData(treeData.value, expandedKeys.value, fieldNames.value);\n    });\n    // ================ selectedKeys =================\n    watchEffect(() => {\n      if (props.selectable) {\n        if (props.selectedKeys !== undefined) {\n          selectedKeys.value = calcSelectedKeys(props.selectedKeys, props);\n        } else if (!init && props.defaultSelectedKeys) {\n          selectedKeys.value = calcSelectedKeys(props.defaultSelectedKeys, props);\n        }\n      }\n    });\n    const {\n      maxLevel,\n      levelEntities\n    } = useMaxLevel(keyEntities);\n    // ================= checkedKeys =================\n    watchEffect(() => {\n      if (props.checkable) {\n        let checkedKeyEntity;\n        if (props.checkedKeys !== undefined) {\n          checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {};\n        } else if (!init && props.defaultCheckedKeys) {\n          checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {};\n        } else if (treeData.value) {\n          // If `treeData` changed, we also need check it\n          checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {\n            checkedKeys: checkedKeys.value,\n            halfCheckedKeys: halfCheckedKeys.value\n          };\n        }\n        if (checkedKeyEntity) {\n          let {\n            checkedKeys: newCheckedKeys = [],\n            halfCheckedKeys: newHalfCheckedKeys = []\n          } = checkedKeyEntity;\n          if (!props.checkStrictly) {\n            const conductKeys = conductCheck(newCheckedKeys, true, keyEntities.value, maxLevel.value, levelEntities.value);\n            ({\n              checkedKeys: newCheckedKeys,\n              halfCheckedKeys: newHalfCheckedKeys\n            } = conductKeys);\n          }\n          checkedKeys.value = newCheckedKeys;\n          halfCheckedKeys.value = newHalfCheckedKeys;\n        }\n      }\n    });\n    // ================= loadedKeys ==================\n    watchEffect(() => {\n      if (props.loadedKeys) {\n        loadedKeys.value = props.loadedKeys;\n      }\n    });\n    const resetDragState = () => {\n      _extends(dragState, {\n        dragOverNodeKey: null,\n        dropPosition: null,\n        dropLevelOffset: null,\n        dropTargetKey: null,\n        dropContainerKey: null,\n        dropTargetPos: null,\n        dropAllowed: false\n      });\n    };\n    const scrollTo = scroll => {\n      listRef.value.scrollTo(scroll);\n    };\n    watch(() => props.activeKey, () => {\n      if (props.activeKey !== undefined) {\n        activeKey.value = props.activeKey;\n      }\n    }, {\n      immediate: true\n    });\n    watch(activeKey, val => {\n      nextTick(() => {\n        if (val !== null) {\n          scrollTo({\n            key: val\n          });\n        }\n      });\n    }, {\n      immediate: true,\n      flush: 'post'\n    });\n    // =========================== Expanded ===========================\n    /** Set uncontrolled `expandedKeys`. This will also auto update `flattenNodes`. */\n    const setExpandedKeys = keys => {\n      if (props.expandedKeys === undefined) {\n        expandedKeys.value = keys;\n      }\n    };\n    const cleanDragState = () => {\n      if (dragState.draggingNodeKey !== null) {\n        _extends(dragState, {\n          draggingNodeKey: null,\n          dropPosition: null,\n          dropContainerKey: null,\n          dropTargetKey: null,\n          dropLevelOffset: null,\n          dropAllowed: true,\n          dragOverNodeKey: null\n        });\n      }\n      dragStartMousePosition = null;\n      currentMouseOverDroppableNodeKey = null;\n    };\n    // if onNodeDragEnd is called, onWindowDragEnd won't be called since stopPropagation() is called\n    const onNodeDragEnd = (event, node) => {\n      const {\n        onDragend\n      } = props;\n      dragState.dragOverNodeKey = null;\n      cleanDragState();\n      onDragend === null || onDragend === void 0 ? void 0 : onDragend({\n        event,\n        node: node.eventData\n      });\n      dragNode = null;\n    };\n    // since stopPropagation() is called in treeNode\n    // if onWindowDrag is called, whice means state is keeped, drag state should be cleared\n    const onWindowDragEnd = event => {\n      onNodeDragEnd(event, null, true);\n      window.removeEventListener('dragend', onWindowDragEnd);\n    };\n    const onNodeDragStart = (event, node) => {\n      const {\n        onDragstart\n      } = props;\n      const {\n        eventKey,\n        eventData\n      } = node;\n      dragNode = node;\n      dragStartMousePosition = {\n        x: event.clientX,\n        y: event.clientY\n      };\n      const newExpandedKeys = arrDel(expandedKeys.value, eventKey);\n      dragState.draggingNodeKey = eventKey;\n      dragState.dragChildrenKeys = getDragChildrenKeys(eventKey, keyEntities.value);\n      indent.value = listRef.value.getIndentWidth();\n      setExpandedKeys(newExpandedKeys);\n      window.addEventListener('dragend', onWindowDragEnd);\n      if (onDragstart) {\n        onDragstart({\n          event,\n          node: eventData\n        });\n      }\n    };\n    /**\r\n     * [Legacy] Select handler is smaller than node,\r\n     * so that this will trigger when drag enter node or select handler.\r\n     * This is a little tricky if customize css without padding.\r\n     * Better for use mouse move event to refresh drag state.\r\n     * But let's just keep it to avoid event trigger logic change.\r\n     */\n    const onNodeDragEnter = (event, node) => {\n      const {\n        onDragenter,\n        onExpand,\n        allowDrop,\n        direction\n      } = props;\n      const {\n        pos,\n        eventKey\n      } = node;\n      // record the key of node which is latest entered, used in dragleave event.\n      if (currentMouseOverDroppableNodeKey !== eventKey) {\n        currentMouseOverDroppableNodeKey = eventKey;\n      }\n      if (!dragNode) {\n        resetDragState();\n        return;\n      }\n      const {\n        dropPosition,\n        dropLevelOffset,\n        dropTargetKey,\n        dropContainerKey,\n        dropTargetPos,\n        dropAllowed,\n        dragOverNodeKey\n      } = calcDropPosition(event, dragNode, node, indent.value, dragStartMousePosition, allowDrop, flattenNodes.value, keyEntities.value, expandedKeysSet.value, direction);\n      if (\n      // don't allow drop inside its children\n      dragState.dragChildrenKeys.indexOf(dropTargetKey) !== -1 ||\n      // don't allow drop when drop is not allowed caculated by calcDropPosition\n      !dropAllowed) {\n        resetDragState();\n        return;\n      }\n      // Side effect for delay drag\n      if (!delayedDragEnterLogic) {\n        delayedDragEnterLogic = {};\n      }\n      Object.keys(delayedDragEnterLogic).forEach(key => {\n        clearTimeout(delayedDragEnterLogic[key]);\n      });\n      if (dragNode.eventKey !== node.eventKey) {\n        // hoist expand logic here\n        // since if logic is on the bottom\n        // it will be blocked by abstract dragover node check\n        //   => if you dragenter from top, you mouse will still be consider as in the top node\n        delayedDragEnterLogic[pos] = window.setTimeout(() => {\n          if (dragState.draggingNodeKey === null) return;\n          let newExpandedKeys = expandedKeys.value.slice();\n          const entity = keyEntities.value[node.eventKey];\n          if (entity && (entity.children || []).length) {\n            newExpandedKeys = arrAdd(expandedKeys.value, node.eventKey);\n          }\n          setExpandedKeys(newExpandedKeys);\n          if (onExpand) {\n            onExpand(newExpandedKeys, {\n              node: node.eventData,\n              expanded: true,\n              nativeEvent: event\n            });\n          }\n        }, 800);\n      }\n      // Skip if drag node is self\n      if (dragNode.eventKey === dropTargetKey && dropLevelOffset === 0) {\n        resetDragState();\n        return;\n      }\n      // Update drag over node and drag state\n      _extends(dragState, {\n        dragOverNodeKey,\n        dropPosition,\n        dropLevelOffset,\n        dropTargetKey,\n        dropContainerKey,\n        dropTargetPos,\n        dropAllowed\n      });\n      if (onDragenter) {\n        onDragenter({\n          event,\n          node: node.eventData,\n          expandedKeys: expandedKeys.value\n        });\n      }\n    };\n    const onNodeDragOver = (event, node) => {\n      const {\n        onDragover,\n        allowDrop,\n        direction\n      } = props;\n      if (!dragNode) {\n        return;\n      }\n      const {\n        dropPosition,\n        dropLevelOffset,\n        dropTargetKey,\n        dropContainerKey,\n        dropAllowed,\n        dropTargetPos,\n        dragOverNodeKey\n      } = calcDropPosition(event, dragNode, node, indent.value, dragStartMousePosition, allowDrop, flattenNodes.value, keyEntities.value, expandedKeysSet.value, direction);\n      if (dragState.dragChildrenKeys.indexOf(dropTargetKey) !== -1 || !dropAllowed) {\n        // don't allow drop inside its children\n        // don't allow drop when drop is not allowed caculated by calcDropPosition\n        return;\n      }\n      // Update drag position\n      if (dragNode.eventKey === dropTargetKey && dropLevelOffset === 0) {\n        if (!(dragState.dropPosition === null && dragState.dropLevelOffset === null && dragState.dropTargetKey === null && dragState.dropContainerKey === null && dragState.dropTargetPos === null && dragState.dropAllowed === false && dragState.dragOverNodeKey === null)) {\n          resetDragState();\n        }\n      } else if (!(dropPosition === dragState.dropPosition && dropLevelOffset === dragState.dropLevelOffset && dropTargetKey === dragState.dropTargetKey && dropContainerKey === dragState.dropContainerKey && dropTargetPos === dragState.dropTargetPos && dropAllowed === dragState.dropAllowed && dragOverNodeKey === dragState.dragOverNodeKey)) {\n        _extends(dragState, {\n          dropPosition,\n          dropLevelOffset,\n          dropTargetKey,\n          dropContainerKey,\n          dropTargetPos,\n          dropAllowed,\n          dragOverNodeKey\n        });\n      }\n      if (onDragover) {\n        onDragover({\n          event,\n          node: node.eventData\n        });\n      }\n    };\n    const onNodeDragLeave = (event, node) => {\n      // if it is outside the droppable area\n      // currentMouseOverDroppableNodeKey will be updated in dragenter event when into another droppable receiver.\n      if (currentMouseOverDroppableNodeKey === node.eventKey && !event.currentTarget.contains(event.relatedTarget)) {\n        resetDragState();\n        currentMouseOverDroppableNodeKey = null;\n      }\n      const {\n        onDragleave\n      } = props;\n      if (onDragleave) {\n        onDragleave({\n          event,\n          node: node.eventData\n        });\n      }\n    };\n    const onNodeDrop = function (event, _node) {\n      let outsideTree = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var _a;\n      const {\n        dragChildrenKeys,\n        dropPosition,\n        dropTargetKey,\n        dropTargetPos,\n        dropAllowed\n      } = dragState;\n      if (!dropAllowed) return;\n      const {\n        onDrop\n      } = props;\n      dragState.dragOverNodeKey = null;\n      cleanDragState();\n      if (dropTargetKey === null) return;\n      const abstractDropNodeProps = _extends(_extends({}, getTreeNodeProps(dropTargetKey, toRaw(treeNodeRequiredProps.value))), {\n        active: ((_a = activeItem.value) === null || _a === void 0 ? void 0 : _a.key) === dropTargetKey,\n        data: keyEntities.value[dropTargetKey].node\n      });\n      const dropToChild = dragChildrenKeys.indexOf(dropTargetKey) !== -1;\n      warning(!dropToChild, \"Can not drop to dragNode's children node. Maybe this is a bug of ant-design-vue. Please report an issue.\");\n      const posArr = posToArr(dropTargetPos);\n      const dropResult = {\n        event,\n        node: convertNodePropsToEventData(abstractDropNodeProps),\n        dragNode: dragNode ? dragNode.eventData : null,\n        dragNodesKeys: [dragNode.eventKey].concat(dragChildrenKeys),\n        dropToGap: dropPosition !== 0,\n        dropPosition: dropPosition + Number(posArr[posArr.length - 1])\n      };\n      if (!outsideTree) {\n        onDrop === null || onDrop === void 0 ? void 0 : onDrop(dropResult);\n      }\n      dragNode = null;\n    };\n    const triggerExpandActionExpand = (e, treeNode) => {\n      const {\n        expanded,\n        key\n      } = treeNode;\n      const node = flattenNodes.value.filter(nodeItem => nodeItem.key === key)[0];\n      const eventNode = convertNodePropsToEventData(_extends(_extends({}, getTreeNodeProps(key, treeNodeRequiredProps.value)), {\n        data: node.data\n      }));\n      setExpandedKeys(expanded ? arrDel(expandedKeys.value, key) : arrAdd(expandedKeys.value, key));\n      onNodeExpand(e, eventNode);\n    };\n    const onNodeClick = (e, treeNode) => {\n      const {\n        onClick,\n        expandAction\n      } = props;\n      if (expandAction === 'click') {\n        triggerExpandActionExpand(e, treeNode);\n      }\n      if (onClick) {\n        onClick(e, treeNode);\n      }\n    };\n    const onNodeDoubleClick = (e, treeNode) => {\n      const {\n        onDblclick,\n        expandAction\n      } = props;\n      if (expandAction === 'doubleclick' || expandAction === 'dblclick') {\n        triggerExpandActionExpand(e, treeNode);\n      }\n      if (onDblclick) {\n        onDblclick(e, treeNode);\n      }\n    };\n    const onNodeSelect = (e, treeNode) => {\n      let newSelectedKeys = selectedKeys.value;\n      const {\n        onSelect,\n        multiple\n      } = props;\n      const {\n        selected\n      } = treeNode;\n      const key = treeNode[fieldNames.value.key];\n      const targetSelected = !selected;\n      // Update selected keys\n      if (!targetSelected) {\n        newSelectedKeys = arrDel(newSelectedKeys, key);\n      } else if (!multiple) {\n        newSelectedKeys = [key];\n      } else {\n        newSelectedKeys = arrAdd(newSelectedKeys, key);\n      }\n      // [Legacy] Not found related usage in doc or upper libs\n      const keyEntitiesValue = keyEntities.value;\n      const selectedNodes = newSelectedKeys.map(selectedKey => {\n        const entity = keyEntitiesValue[selectedKey];\n        if (!entity) return null;\n        return entity.node;\n      }).filter(node => node);\n      if (props.selectedKeys === undefined) {\n        selectedKeys.value = newSelectedKeys;\n      }\n      if (onSelect) {\n        onSelect(newSelectedKeys, {\n          event: 'select',\n          selected: targetSelected,\n          node: treeNode,\n          selectedNodes,\n          nativeEvent: e\n        });\n      }\n    };\n    const onNodeCheck = (e, treeNode, checked) => {\n      const {\n        checkStrictly,\n        onCheck\n      } = props;\n      const key = treeNode[fieldNames.value.key];\n      // Prepare trigger arguments\n      let checkedObj;\n      const eventObj = {\n        event: 'check',\n        node: treeNode,\n        checked,\n        nativeEvent: e\n      };\n      const keyEntitiesValue = keyEntities.value;\n      if (checkStrictly) {\n        const newCheckedKeys = checked ? arrAdd(checkedKeys.value, key) : arrDel(checkedKeys.value, key);\n        const newHalfCheckedKeys = arrDel(halfCheckedKeys.value, key);\n        checkedObj = {\n          checked: newCheckedKeys,\n          halfChecked: newHalfCheckedKeys\n        };\n        eventObj.checkedNodes = newCheckedKeys.map(checkedKey => keyEntitiesValue[checkedKey]).filter(entity => entity).map(entity => entity.node);\n        if (props.checkedKeys === undefined) {\n          checkedKeys.value = newCheckedKeys;\n        }\n      } else {\n        // Always fill first\n        let {\n          checkedKeys: newCheckedKeys,\n          halfCheckedKeys: newHalfCheckedKeys\n        } = conductCheck([...checkedKeys.value, key], true, keyEntitiesValue, maxLevel.value, levelEntities.value);\n        // If remove, we do it again to correction\n        if (!checked) {\n          const keySet = new Set(newCheckedKeys);\n          keySet.delete(key);\n          ({\n            checkedKeys: newCheckedKeys,\n            halfCheckedKeys: newHalfCheckedKeys\n          } = conductCheck(Array.from(keySet), {\n            checked: false,\n            halfCheckedKeys: newHalfCheckedKeys\n          }, keyEntitiesValue, maxLevel.value, levelEntities.value));\n        }\n        checkedObj = newCheckedKeys;\n        // [Legacy] This is used for vc-tree-select`\n        eventObj.checkedNodes = [];\n        eventObj.checkedNodesPositions = [];\n        eventObj.halfCheckedKeys = newHalfCheckedKeys;\n        newCheckedKeys.forEach(checkedKey => {\n          const entity = keyEntitiesValue[checkedKey];\n          if (!entity) return;\n          const {\n            node,\n            pos\n          } = entity;\n          eventObj.checkedNodes.push(node);\n          eventObj.checkedNodesPositions.push({\n            node,\n            pos\n          });\n        });\n        if (props.checkedKeys === undefined) {\n          checkedKeys.value = newCheckedKeys;\n          halfCheckedKeys.value = newHalfCheckedKeys;\n        }\n      }\n      if (onCheck) {\n        onCheck(checkedObj, eventObj);\n      }\n    };\n    const onNodeLoad = treeNode => {\n      const key = treeNode[fieldNames.value.key];\n      const loadPromise = new Promise((resolve, reject) => {\n        // We need to get the latest state of loading/loaded keys\n        const {\n          loadData,\n          onLoad\n        } = props;\n        if (!loadData || loadedKeysSet.value.has(key) || loadingKeysSet.value.has(key)) {\n          return null;\n        }\n        // Process load data\n        const promise = loadData(treeNode);\n        promise.then(() => {\n          const newLoadedKeys = arrAdd(loadedKeys.value, key);\n          const newLoadingKeys = arrDel(loadingKeys.value, key);\n          // onLoad should trigger before internal setState to avoid `loadData` trigger twice.\n          // https://github.com/ant-design/ant-design/issues/12464\n          if (onLoad) {\n            onLoad(newLoadedKeys, {\n              event: 'load',\n              node: treeNode\n            });\n          }\n          if (props.loadedKeys === undefined) {\n            loadedKeys.value = newLoadedKeys;\n          }\n          loadingKeys.value = newLoadingKeys;\n          resolve();\n        }).catch(e => {\n          const newLoadingKeys = arrDel(loadingKeys.value, key);\n          loadingKeys.value = newLoadingKeys;\n          // If exceed max retry times, we give up retry\n          loadingRetryTimes[key] = (loadingRetryTimes[key] || 0) + 1;\n          if (loadingRetryTimes[key] >= MAX_RETRY_TIMES) {\n            warning(false, 'Retry for `loadData` many times but still failed. No more retry.');\n            const newLoadedKeys = arrAdd(loadedKeys.value, key);\n            if (props.loadedKeys === undefined) {\n              loadedKeys.value = newLoadedKeys;\n            }\n            resolve();\n          }\n          reject(e);\n        });\n        loadingKeys.value = arrAdd(loadingKeys.value, key);\n      });\n      // Not care warning if we ignore this\n      loadPromise.catch(() => {});\n      return loadPromise;\n    };\n    const onNodeMouseEnter = (event, node) => {\n      const {\n        onMouseenter\n      } = props;\n      if (onMouseenter) {\n        onMouseenter({\n          event,\n          node\n        });\n      }\n    };\n    const onNodeMouseLeave = (event, node) => {\n      const {\n        onMouseleave\n      } = props;\n      if (onMouseleave) {\n        onMouseleave({\n          event,\n          node\n        });\n      }\n    };\n    const onNodeContextMenu = (event, node) => {\n      const {\n        onRightClick\n      } = props;\n      if (onRightClick) {\n        event.preventDefault();\n        onRightClick({\n          event,\n          node\n        });\n      }\n    };\n    const onFocus = e => {\n      const {\n        onFocus\n      } = props;\n      focused.value = true;\n      if (onFocus) {\n        onFocus(e);\n      }\n    };\n    const onBlur = e => {\n      const {\n        onBlur\n      } = props;\n      focused.value = false;\n      onActiveChange(null);\n      if (onBlur) {\n        onBlur(e);\n      }\n    };\n    const onNodeExpand = (e, treeNode) => {\n      let newExpandedKeys = expandedKeys.value;\n      const {\n        onExpand,\n        loadData\n      } = props;\n      const {\n        expanded\n      } = treeNode;\n      const key = treeNode[fieldNames.value.key];\n      // Do nothing when motion is in progress\n      if (listChanging.value) {\n        return;\n      }\n      // Update selected keys\n      const index = newExpandedKeys.indexOf(key);\n      const targetExpanded = !expanded;\n      warning(expanded && index !== -1 || !expanded && index === -1, 'Expand state not sync with index check');\n      if (targetExpanded) {\n        newExpandedKeys = arrAdd(newExpandedKeys, key);\n      } else {\n        newExpandedKeys = arrDel(newExpandedKeys, key);\n      }\n      setExpandedKeys(newExpandedKeys);\n      if (onExpand) {\n        onExpand(newExpandedKeys, {\n          node: treeNode,\n          expanded: targetExpanded,\n          nativeEvent: e\n        });\n      }\n      // Async Load data\n      if (targetExpanded && loadData) {\n        const loadPromise = onNodeLoad(treeNode);\n        if (loadPromise) {\n          loadPromise.then(() => {\n            // [Legacy] Refresh logic\n            // const newFlattenTreeData = flattenTreeData(\n            //   treeData.value,\n            //   newExpandedKeys,\n            //   fieldNames.value,\n            // );\n            // flattenNodes.value = newFlattenTreeData;\n          }).catch(e => {\n            const expandedKeysToRestore = arrDel(expandedKeys.value, key);\n            setExpandedKeys(expandedKeysToRestore);\n            Promise.reject(e);\n          });\n        }\n      }\n    };\n    const onListChangeStart = () => {\n      listChanging.value = true;\n    };\n    const onListChangeEnd = () => {\n      setTimeout(() => {\n        listChanging.value = false;\n      });\n    };\n    // =========================== Keyboard ===========================\n    const onActiveChange = newActiveKey => {\n      const {\n        onActiveChange\n      } = props;\n      if (activeKey.value === newActiveKey) {\n        return;\n      }\n      if (props.activeKey !== undefined) {\n        activeKey.value = newActiveKey;\n      }\n      if (newActiveKey !== null) {\n        scrollTo({\n          key: newActiveKey\n        });\n      }\n      if (onActiveChange) {\n        onActiveChange(newActiveKey);\n      }\n    };\n    const activeItem = computed(() => {\n      if (activeKey.value === null) {\n        return null;\n      }\n      return flattenNodes.value.find(_ref4 => {\n        let {\n          key\n        } = _ref4;\n        return key === activeKey.value;\n      }) || null;\n    });\n    const offsetActiveKey = offset => {\n      let index = flattenNodes.value.findIndex(_ref5 => {\n        let {\n          key\n        } = _ref5;\n        return key === activeKey.value;\n      });\n      // Align with index\n      if (index === -1 && offset < 0) {\n        index = flattenNodes.value.length;\n      }\n      index = (index + offset + flattenNodes.value.length) % flattenNodes.value.length;\n      const item = flattenNodes.value[index];\n      if (item) {\n        const {\n          key\n        } = item;\n        onActiveChange(key);\n      } else {\n        onActiveChange(null);\n      }\n    };\n    const activeItemEventNode = computed(() => {\n      return convertNodePropsToEventData(_extends(_extends({}, getTreeNodeProps(activeKey.value, treeNodeRequiredProps.value)), {\n        data: activeItem.value.data,\n        active: true\n      }));\n    });\n    const onKeydown = event => {\n      const {\n        onKeydown,\n        checkable,\n        selectable\n      } = props;\n      // >>>>>>>>>> Direction\n      switch (event.which) {\n        case KeyCode.UP:\n          {\n            offsetActiveKey(-1);\n            event.preventDefault();\n            break;\n          }\n        case KeyCode.DOWN:\n          {\n            offsetActiveKey(1);\n            event.preventDefault();\n            break;\n          }\n      }\n      // >>>>>>>>>> Expand & Selection\n      const item = activeItem.value;\n      if (item && item.data) {\n        const expandable = item.data.isLeaf === false || !!(item.data.children || []).length;\n        const eventNode = activeItemEventNode.value;\n        switch (event.which) {\n          // >>> Expand\n          case KeyCode.LEFT:\n            {\n              // Collapse if possible\n              if (expandable && expandedKeysSet.value.has(activeKey.value)) {\n                onNodeExpand({}, eventNode);\n              } else if (item.parent) {\n                onActiveChange(item.parent.key);\n              }\n              event.preventDefault();\n              break;\n            }\n          case KeyCode.RIGHT:\n            {\n              // Expand if possible\n              if (expandable && !expandedKeysSet.value.has(activeKey.value)) {\n                onNodeExpand({}, eventNode);\n              } else if (item.children && item.children.length) {\n                onActiveChange(item.children[0].key);\n              }\n              event.preventDefault();\n              break;\n            }\n          // Selection\n          case KeyCode.ENTER:\n          case KeyCode.SPACE:\n            {\n              if (checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox) {\n                onNodeCheck({}, eventNode, !checkedKeysSet.value.has(activeKey.value));\n              } else if (!checkable && selectable && !eventNode.disabled && eventNode.selectable !== false) {\n                onNodeSelect({}, eventNode);\n              }\n              break;\n            }\n        }\n      }\n      if (onKeydown) {\n        onKeydown(event);\n      }\n    };\n    expose({\n      onNodeExpand,\n      scrollTo,\n      onKeydown,\n      selectedKeys: computed(() => selectedKeys.value),\n      checkedKeys: computed(() => checkedKeys.value),\n      halfCheckedKeys: computed(() => halfCheckedKeys.value),\n      loadedKeys: computed(() => loadedKeys.value),\n      loadingKeys: computed(() => loadingKeys.value),\n      expandedKeys: computed(() => expandedKeys.value)\n    });\n    onUnmounted(() => {\n      window.removeEventListener('dragend', onWindowDragEnd);\n      destroyed.value = true;\n    });\n    useProvideKeysState({\n      expandedKeys,\n      selectedKeys,\n      loadedKeys,\n      loadingKeys,\n      checkedKeys,\n      halfCheckedKeys,\n      expandedKeysSet,\n      selectedKeysSet,\n      loadedKeysSet,\n      loadingKeysSet,\n      checkedKeysSet,\n      halfCheckedKeysSet,\n      flattenNodes\n    });\n    return () => {\n      const {\n        // focused,\n        // flattenNodes,\n        // keyEntities,\n        draggingNodeKey,\n        // activeKey,\n        dropLevelOffset,\n        dropContainerKey,\n        dropTargetKey,\n        dropPosition,\n        dragOverNodeKey\n        // indent,\n      } = dragState;\n      const {\n        prefixCls,\n        showLine,\n        focusable,\n        tabindex = 0,\n        selectable,\n        showIcon,\n        icon = slots.icon,\n        switcherIcon,\n        draggable,\n        checkable,\n        checkStrictly,\n        disabled,\n        motion,\n        loadData,\n        filterTreeNode,\n        height,\n        itemHeight,\n        virtual,\n        dropIndicatorRender,\n        onContextmenu,\n        onScroll,\n        direction,\n        rootClassName,\n        rootStyle\n      } = props;\n      const {\n        class: className,\n        style\n      } = attrs;\n      const domProps = pickAttrs(_extends(_extends({}, props), attrs), {\n        aria: true,\n        data: true\n      });\n      // It's better move to hooks but we just simply keep here\n      let draggableConfig;\n      if (draggable) {\n        if (typeof draggable === 'object') {\n          draggableConfig = draggable;\n        } else if (typeof draggable === 'function') {\n          draggableConfig = {\n            nodeDraggable: draggable\n          };\n        } else {\n          draggableConfig = {};\n        }\n      } else {\n        draggableConfig = false;\n      }\n      return _createVNode(TreeContext, {\n        \"value\": {\n          prefixCls,\n          selectable,\n          showIcon,\n          icon,\n          switcherIcon,\n          draggable: draggableConfig,\n          draggingNodeKey,\n          checkable,\n          customCheckable: slots.checkable,\n          checkStrictly,\n          disabled,\n          keyEntities: keyEntities.value,\n          dropLevelOffset,\n          dropContainerKey,\n          dropTargetKey,\n          dropPosition,\n          dragOverNodeKey,\n          dragging: draggingNodeKey !== null,\n          indent: indent.value,\n          direction,\n          dropIndicatorRender,\n          loadData,\n          filterTreeNode,\n          onNodeClick,\n          onNodeDoubleClick,\n          onNodeExpand,\n          onNodeSelect,\n          onNodeCheck,\n          onNodeLoad,\n          onNodeMouseEnter,\n          onNodeMouseLeave,\n          onNodeContextMenu,\n          onNodeDragStart,\n          onNodeDragEnter,\n          onNodeDragOver,\n          onNodeDragLeave,\n          onNodeDragEnd,\n          onNodeDrop,\n          slots\n        }\n      }, {\n        default: () => [_createVNode(\"div\", {\n          \"role\": \"tree\",\n          \"class\": classNames(prefixCls, className, rootClassName, {\n            [`${prefixCls}-show-line`]: showLine,\n            [`${prefixCls}-focused`]: focused.value,\n            [`${prefixCls}-active-focused`]: activeKey.value !== null\n          }),\n          \"style\": rootStyle\n        }, [_createVNode(NodeList, _objectSpread({\n          \"ref\": listRef,\n          \"prefixCls\": prefixCls,\n          \"style\": style,\n          \"disabled\": disabled,\n          \"selectable\": selectable,\n          \"checkable\": !!checkable,\n          \"motion\": motion,\n          \"height\": height,\n          \"itemHeight\": itemHeight,\n          \"virtual\": virtual,\n          \"focusable\": focusable,\n          \"focused\": focused.value,\n          \"tabindex\": tabindex,\n          \"activeItem\": activeItem.value,\n          \"onFocus\": onFocus,\n          \"onBlur\": onBlur,\n          \"onKeydown\": onKeydown,\n          \"onActiveChange\": onActiveChange,\n          \"onListChangeStart\": onListChangeStart,\n          \"onListChangeEnd\": onListChangeEnd,\n          \"onContextmenu\": onContextmenu,\n          \"onScroll\": onScroll\n        }, domProps), null)])]\n      });\n    };\n  }\n});","map":{"version":3,"names":["_objectSpread","_extends","createVNode","_createVNode","useProvideKeysState","TreeContext","getDragChildrenKeys","parseCheckedKeys","conductExpandParent","calcSelectedKeys","calcDropPosition","arrAdd","arrDel","posToArr","flattenTreeData","convertTreeToData","convertDataToEntities","convertNodePropsToEventData","getTreeNodeProps","fillFieldNames","NodeList","MOTION_KEY","MotionEntity","conductCheck","DropIndicator","computed","defineComponent","onUnmounted","reactive","shallowRef","watch","watchEffect","nextTick","toRaw","initDefaultProps","treeProps","warning","KeyCode","classNames","pickAttrs","useMaxLevel","MAX_RETRY_TIMES","compatConfig","MODE","name","inheritAttrs","props","prefixCls","showLine","showIcon","selectable","multiple","checkable","disabled","checkStrictly","draggable","expandAction","defaultExpandParent","autoExpandParent","defaultExpandAll","defaultExpandedKeys","defaultCheckedKeys","defaultSelectedKeys","dropIndicatorRender","allowDrop","setup","_ref","attrs","slots","expose","destroyed","delayedDragEnterLogic","indent","selectedKeys","checkedKeys","halfCheckedKeys","loadedKeys","loadingKeys","expandedKeys","loadingRetryTimes","dragState","draggingNodeKey","dragChildrenKeys","dropTargetKey","dropPosition","dropContainerKey","dropLevelOffset","dropTargetPos","dropAllowed","dragOverNodeKey","treeData","children","value","undefined","slice","immediate","deep","keyEntities","focused","activeKey","listChanging","fieldNames","listRef","dragStartMousePosition","dragNode","currentMouseOverDroppableNodeKey","treeNodeRequiredProps","expandedKeysSet","selectedKeysSet","loadedKeysSet","loadingKeysSet","checkedKeysSet","halfCheckedKeysSet","Set","entitiesMap","init","_ref2","_ref3","_newKeys","newAutoExpandParent","_oldKeys","oldAutoExpandParent","keys","cloneKeyEntities","Object","map","key","flattenNodes","maxLevel","levelEntities","checkedKeyEntity","newCheckedKeys","newHalfCheckedKeys","conductKeys","resetDragState","scrollTo","scroll","val","flush","setExpandedKeys","cleanDragState","onNodeDragEnd","event","node","onDragend","eventData","onWindowDragEnd","window","removeEventListener","onNodeDragStart","onDragstart","eventKey","x","clientX","y","clientY","newExpandedKeys","getIndentWidth","addEventListener","onNodeDragEnter","onDragenter","onExpand","direction","pos","indexOf","forEach","clearTimeout","setTimeout","entity","length","expanded","nativeEvent","onNodeDragOver","onDragover","onNodeDragLeave","currentTarget","contains","relatedTarget","onDragleave","onNodeDrop","_node","outsideTree","arguments","_a","onDrop","abstractDropNodeProps","active","activeItem","data","dropToChild","posArr","dropResult","dragNodesKeys","concat","dropToGap","Number","triggerExpandActionExpand","e","treeNode","filter","nodeItem","eventNode","onNodeExpand","onNodeClick","onClick","onNodeDoubleClick","onDblclick","onNodeSelect","newSelectedKeys","onSelect","selected","targetSelected","keyEntitiesValue","selectedNodes","selectedKey","onNodeCheck","checked","onCheck","checkedObj","eventObj","halfChecked","checkedNodes","checkedKey","keySet","delete","Array","from","checkedNodesPositions","push","onNodeLoad","loadPromise","Promise","resolve","reject","loadData","onLoad","has","promise","then","newLoadedKeys","newLoadingKeys","catch","onNodeMouseEnter","onMouseenter","onNodeMouseLeave","onMouseleave","onNodeContextMenu","onRightClick","preventDefault","onFocus","onBlur","onActiveChange","index","targetExpanded","expandedKeysToRestore","onListChangeStart","onListChangeEnd","newActiveKey","find","_ref4","offsetActiveKey","offset","findIndex","_ref5","item","activeItemEventNode","onKeydown","which","UP","DOWN","expandable","isLeaf","LEFT","parent","RIGHT","ENTER","SPACE","disableCheckbox","focusable","tabindex","icon","switcherIcon","motion","filterTreeNode","height","itemHeight","virtual","onContextmenu","onScroll","rootClassName","rootStyle","class","className","style","domProps","aria","draggableConfig","nodeDraggable","customCheckable","dragging","default"],"sources":["D:/Work/大二下/DB小学期/gitspace11/2023-TJU-DBD-Police-Affair-System/My-front/dbproject/node_modules/ant-design-vue/es/vc-tree/Tree.js"],"sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\r\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\r\nimport { createVNode as _createVNode } from \"vue\";\r\nimport { useProvideKeysState, TreeContext } from './contextTypes';\r\nimport { getDragChildrenKeys, parseCheckedKeys, conductExpandParent, calcSelectedKeys, calcDropPosition, arrAdd, arrDel, posToArr } from './util';\r\nimport { flattenTreeData, convertTreeToData, convertDataToEntities, convertNodePropsToEventData, getTreeNodeProps, fillFieldNames } from './utils/treeUtil';\r\nimport NodeList, { MOTION_KEY, MotionEntity } from './NodeList';\r\nimport { conductCheck } from './utils/conductUtil';\r\nimport DropIndicator from './DropIndicator';\r\nimport { computed, defineComponent, onUnmounted, reactive, shallowRef, watch, watchEffect, nextTick, toRaw } from 'vue';\r\nimport initDefaultProps from '../_util/props-util/initDefaultProps';\r\nimport { treeProps } from './props';\r\nimport { warning } from '../vc-util/warning';\r\nimport KeyCode from '../_util/KeyCode';\r\nimport classNames from '../_util/classNames';\r\nimport pickAttrs from '../_util/pickAttrs';\r\nimport useMaxLevel from './useMaxLevel';\r\nconst MAX_RETRY_TIMES = 10;\r\nexport default defineComponent({\r\n  compatConfig: {\r\n    MODE: 3\r\n  },\r\n  name: 'Tree',\r\n  inheritAttrs: false,\r\n  props: initDefaultProps(treeProps(), {\r\n    prefixCls: 'vc-tree',\r\n    showLine: false,\r\n    showIcon: true,\r\n    selectable: true,\r\n    multiple: false,\r\n    checkable: false,\r\n    disabled: false,\r\n    checkStrictly: false,\r\n    draggable: false,\r\n    expandAction: false,\r\n    defaultExpandParent: true,\r\n    autoExpandParent: false,\r\n    defaultExpandAll: false,\r\n    defaultExpandedKeys: [],\r\n    defaultCheckedKeys: [],\r\n    defaultSelectedKeys: [],\r\n    dropIndicatorRender: DropIndicator,\r\n    allowDrop: () => true\r\n  }),\r\n  setup(props, _ref) {\r\n    let {\r\n      attrs,\r\n      slots,\r\n      expose\r\n    } = _ref;\r\n    const destroyed = shallowRef(false);\r\n    let delayedDragEnterLogic = {};\r\n    const indent = shallowRef();\r\n    const selectedKeys = shallowRef([]);\r\n    const checkedKeys = shallowRef([]);\r\n    const halfCheckedKeys = shallowRef([]);\r\n    const loadedKeys = shallowRef([]);\r\n    const loadingKeys = shallowRef([]);\r\n    const expandedKeys = shallowRef([]);\r\n    const loadingRetryTimes = {};\r\n    const dragState = reactive({\r\n      draggingNodeKey: null,\r\n      dragChildrenKeys: [],\r\n      // dropTargetKey is the key of abstract-drop-node\r\n      // the abstract-drop-node is the real drop node when drag and drop\r\n      // not the DOM drag over node\r\n      dropTargetKey: null,\r\n      dropPosition: null,\r\n      dropContainerKey: null,\r\n      dropLevelOffset: null,\r\n      dropTargetPos: null,\r\n      dropAllowed: true,\r\n      // the abstract-drag-over-node\r\n      // if mouse is on the bottom of top dom node or no the top of the bottom dom node\r\n      // abstract-drag-over-node is the top node\r\n      dragOverNodeKey: null\r\n    });\r\n    const treeData = shallowRef([]);\r\n    watch([() => props.treeData, () => props.children], () => {\r\n      treeData.value = props.treeData !== undefined ? toRaw(props.treeData).slice() : convertTreeToData(toRaw(props.children));\r\n    }, {\r\n      immediate: true,\r\n      deep: true\r\n    });\r\n    const keyEntities = shallowRef({});\r\n    const focused = shallowRef(false);\r\n    const activeKey = shallowRef(null);\r\n    const listChanging = shallowRef(false);\r\n    const fieldNames = computed(() => fillFieldNames(props.fieldNames));\r\n    const listRef = shallowRef();\r\n    let dragStartMousePosition = null;\r\n    let dragNode = null;\r\n    let currentMouseOverDroppableNodeKey = null;\r\n    const treeNodeRequiredProps = computed(() => {\r\n      return {\r\n        expandedKeysSet: expandedKeysSet.value,\r\n        selectedKeysSet: selectedKeysSet.value,\r\n        loadedKeysSet: loadedKeysSet.value,\r\n        loadingKeysSet: loadingKeysSet.value,\r\n        checkedKeysSet: checkedKeysSet.value,\r\n        halfCheckedKeysSet: halfCheckedKeysSet.value,\r\n        dragOverNodeKey: dragState.dragOverNodeKey,\r\n        dropPosition: dragState.dropPosition,\r\n        keyEntities: keyEntities.value\r\n      };\r\n    });\r\n    const expandedKeysSet = computed(() => {\r\n      return new Set(expandedKeys.value);\r\n    });\r\n    const selectedKeysSet = computed(() => {\r\n      return new Set(selectedKeys.value);\r\n    });\r\n    const loadedKeysSet = computed(() => {\r\n      return new Set(loadedKeys.value);\r\n    });\r\n    const loadingKeysSet = computed(() => {\r\n      return new Set(loadingKeys.value);\r\n    });\r\n    const checkedKeysSet = computed(() => {\r\n      return new Set(checkedKeys.value);\r\n    });\r\n    const halfCheckedKeysSet = computed(() => {\r\n      return new Set(halfCheckedKeys.value);\r\n    });\r\n    watchEffect(() => {\r\n      if (treeData.value) {\r\n        const entitiesMap = convertDataToEntities(treeData.value, {\r\n          fieldNames: fieldNames.value\r\n        });\r\n        keyEntities.value = _extends({\r\n          [MOTION_KEY]: MotionEntity\r\n        }, entitiesMap.keyEntities);\r\n      }\r\n    });\r\n    let init = false; // 处理 defaultXxxx api, 仅仅首次有效\r\n    watch([() => props.expandedKeys, () => props.autoExpandParent, keyEntities],\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    (_ref2, _ref3) => {\r\n      let [_newKeys, newAutoExpandParent] = _ref2;\r\n      let [_oldKeys, oldAutoExpandParent] = _ref3;\r\n      let keys = expandedKeys.value;\r\n      // ================ expandedKeys =================\r\n      if (props.expandedKeys !== undefined || init && newAutoExpandParent !== oldAutoExpandParent) {\r\n        keys = props.autoExpandParent || !init && props.defaultExpandParent ? conductExpandParent(props.expandedKeys, keyEntities.value) : props.expandedKeys;\r\n      } else if (!init && props.defaultExpandAll) {\r\n        const cloneKeyEntities = _extends({}, keyEntities.value);\r\n        delete cloneKeyEntities[MOTION_KEY];\r\n        keys = Object.keys(cloneKeyEntities).map(key => cloneKeyEntities[key].key);\r\n      } else if (!init && props.defaultExpandedKeys) {\r\n        keys = props.autoExpandParent || props.defaultExpandParent ? conductExpandParent(props.defaultExpandedKeys, keyEntities.value) : props.defaultExpandedKeys;\r\n      }\r\n      if (keys) {\r\n        expandedKeys.value = keys;\r\n      }\r\n      init = true;\r\n    }, {\r\n      immediate: true\r\n    });\r\n    // ================ flattenNodes =================\r\n    const flattenNodes = shallowRef([]);\r\n    watchEffect(() => {\r\n      flattenNodes.value = flattenTreeData(treeData.value, expandedKeys.value, fieldNames.value);\r\n    });\r\n    // ================ selectedKeys =================\r\n    watchEffect(() => {\r\n      if (props.selectable) {\r\n        if (props.selectedKeys !== undefined) {\r\n          selectedKeys.value = calcSelectedKeys(props.selectedKeys, props);\r\n        } else if (!init && props.defaultSelectedKeys) {\r\n          selectedKeys.value = calcSelectedKeys(props.defaultSelectedKeys, props);\r\n        }\r\n      }\r\n    });\r\n    const {\r\n      maxLevel,\r\n      levelEntities\r\n    } = useMaxLevel(keyEntities);\r\n    // ================= checkedKeys =================\r\n    watchEffect(() => {\r\n      if (props.checkable) {\r\n        let checkedKeyEntity;\r\n        if (props.checkedKeys !== undefined) {\r\n          checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {};\r\n        } else if (!init && props.defaultCheckedKeys) {\r\n          checkedKeyEntity = parseCheckedKeys(props.defaultCheckedKeys) || {};\r\n        } else if (treeData.value) {\r\n          // If `treeData` changed, we also need check it\r\n          checkedKeyEntity = parseCheckedKeys(props.checkedKeys) || {\r\n            checkedKeys: checkedKeys.value,\r\n            halfCheckedKeys: halfCheckedKeys.value\r\n          };\r\n        }\r\n        if (checkedKeyEntity) {\r\n          let {\r\n            checkedKeys: newCheckedKeys = [],\r\n            halfCheckedKeys: newHalfCheckedKeys = []\r\n          } = checkedKeyEntity;\r\n          if (!props.checkStrictly) {\r\n            const conductKeys = conductCheck(newCheckedKeys, true, keyEntities.value, maxLevel.value, levelEntities.value);\r\n            ({\r\n              checkedKeys: newCheckedKeys,\r\n              halfCheckedKeys: newHalfCheckedKeys\r\n            } = conductKeys);\r\n          }\r\n          checkedKeys.value = newCheckedKeys;\r\n          halfCheckedKeys.value = newHalfCheckedKeys;\r\n        }\r\n      }\r\n    });\r\n    // ================= loadedKeys ==================\r\n    watchEffect(() => {\r\n      if (props.loadedKeys) {\r\n        loadedKeys.value = props.loadedKeys;\r\n      }\r\n    });\r\n    const resetDragState = () => {\r\n      _extends(dragState, {\r\n        dragOverNodeKey: null,\r\n        dropPosition: null,\r\n        dropLevelOffset: null,\r\n        dropTargetKey: null,\r\n        dropContainerKey: null,\r\n        dropTargetPos: null,\r\n        dropAllowed: false\r\n      });\r\n    };\r\n    const scrollTo = scroll => {\r\n      listRef.value.scrollTo(scroll);\r\n    };\r\n    watch(() => props.activeKey, () => {\r\n      if (props.activeKey !== undefined) {\r\n        activeKey.value = props.activeKey;\r\n      }\r\n    }, {\r\n      immediate: true\r\n    });\r\n    watch(activeKey, val => {\r\n      nextTick(() => {\r\n        if (val !== null) {\r\n          scrollTo({\r\n            key: val\r\n          });\r\n        }\r\n      });\r\n    }, {\r\n      immediate: true,\r\n      flush: 'post'\r\n    });\r\n    // =========================== Expanded ===========================\r\n    /** Set uncontrolled `expandedKeys`. This will also auto update `flattenNodes`. */\r\n    const setExpandedKeys = keys => {\r\n      if (props.expandedKeys === undefined) {\r\n        expandedKeys.value = keys;\r\n      }\r\n    };\r\n    const cleanDragState = () => {\r\n      if (dragState.draggingNodeKey !== null) {\r\n        _extends(dragState, {\r\n          draggingNodeKey: null,\r\n          dropPosition: null,\r\n          dropContainerKey: null,\r\n          dropTargetKey: null,\r\n          dropLevelOffset: null,\r\n          dropAllowed: true,\r\n          dragOverNodeKey: null\r\n        });\r\n      }\r\n      dragStartMousePosition = null;\r\n      currentMouseOverDroppableNodeKey = null;\r\n    };\r\n    // if onNodeDragEnd is called, onWindowDragEnd won't be called since stopPropagation() is called\r\n    const onNodeDragEnd = (event, node) => {\r\n      const {\r\n        onDragend\r\n      } = props;\r\n      dragState.dragOverNodeKey = null;\r\n      cleanDragState();\r\n      onDragend === null || onDragend === void 0 ? void 0 : onDragend({\r\n        event,\r\n        node: node.eventData\r\n      });\r\n      dragNode = null;\r\n    };\r\n    // since stopPropagation() is called in treeNode\r\n    // if onWindowDrag is called, whice means state is keeped, drag state should be cleared\r\n    const onWindowDragEnd = event => {\r\n      onNodeDragEnd(event, null, true);\r\n      window.removeEventListener('dragend', onWindowDragEnd);\r\n    };\r\n    const onNodeDragStart = (event, node) => {\r\n      const {\r\n        onDragstart\r\n      } = props;\r\n      const {\r\n        eventKey,\r\n        eventData\r\n      } = node;\r\n      dragNode = node;\r\n      dragStartMousePosition = {\r\n        x: event.clientX,\r\n        y: event.clientY\r\n      };\r\n      const newExpandedKeys = arrDel(expandedKeys.value, eventKey);\r\n      dragState.draggingNodeKey = eventKey;\r\n      dragState.dragChildrenKeys = getDragChildrenKeys(eventKey, keyEntities.value);\r\n      indent.value = listRef.value.getIndentWidth();\r\n      setExpandedKeys(newExpandedKeys);\r\n      window.addEventListener('dragend', onWindowDragEnd);\r\n      if (onDragstart) {\r\n        onDragstart({\r\n          event,\r\n          node: eventData\r\n        });\r\n      }\r\n    };\r\n    /**\r\n     * [Legacy] Select handler is smaller than node,\r\n     * so that this will trigger when drag enter node or select handler.\r\n     * This is a little tricky if customize css without padding.\r\n     * Better for use mouse move event to refresh drag state.\r\n     * But let's just keep it to avoid event trigger logic change.\r\n     */\r\n    const onNodeDragEnter = (event, node) => {\r\n      const {\r\n        onDragenter,\r\n        onExpand,\r\n        allowDrop,\r\n        direction\r\n      } = props;\r\n      const {\r\n        pos,\r\n        eventKey\r\n      } = node;\r\n      // record the key of node which is latest entered, used in dragleave event.\r\n      if (currentMouseOverDroppableNodeKey !== eventKey) {\r\n        currentMouseOverDroppableNodeKey = eventKey;\r\n      }\r\n      if (!dragNode) {\r\n        resetDragState();\r\n        return;\r\n      }\r\n      const {\r\n        dropPosition,\r\n        dropLevelOffset,\r\n        dropTargetKey,\r\n        dropContainerKey,\r\n        dropTargetPos,\r\n        dropAllowed,\r\n        dragOverNodeKey\r\n      } = calcDropPosition(event, dragNode, node, indent.value, dragStartMousePosition, allowDrop, flattenNodes.value, keyEntities.value, expandedKeysSet.value, direction);\r\n      if (\r\n      // don't allow drop inside its children\r\n      dragState.dragChildrenKeys.indexOf(dropTargetKey) !== -1 ||\r\n      // don't allow drop when drop is not allowed caculated by calcDropPosition\r\n      !dropAllowed) {\r\n        resetDragState();\r\n        return;\r\n      }\r\n      // Side effect for delay drag\r\n      if (!delayedDragEnterLogic) {\r\n        delayedDragEnterLogic = {};\r\n      }\r\n      Object.keys(delayedDragEnterLogic).forEach(key => {\r\n        clearTimeout(delayedDragEnterLogic[key]);\r\n      });\r\n      if (dragNode.eventKey !== node.eventKey) {\r\n        // hoist expand logic here\r\n        // since if logic is on the bottom\r\n        // it will be blocked by abstract dragover node check\r\n        //   => if you dragenter from top, you mouse will still be consider as in the top node\r\n        delayedDragEnterLogic[pos] = window.setTimeout(() => {\r\n          if (dragState.draggingNodeKey === null) return;\r\n          let newExpandedKeys = expandedKeys.value.slice();\r\n          const entity = keyEntities.value[node.eventKey];\r\n          if (entity && (entity.children || []).length) {\r\n            newExpandedKeys = arrAdd(expandedKeys.value, node.eventKey);\r\n          }\r\n          setExpandedKeys(newExpandedKeys);\r\n          if (onExpand) {\r\n            onExpand(newExpandedKeys, {\r\n              node: node.eventData,\r\n              expanded: true,\r\n              nativeEvent: event\r\n            });\r\n          }\r\n        }, 800);\r\n      }\r\n      // Skip if drag node is self\r\n      if (dragNode.eventKey === dropTargetKey && dropLevelOffset === 0) {\r\n        resetDragState();\r\n        return;\r\n      }\r\n      // Update drag over node and drag state\r\n      _extends(dragState, {\r\n        dragOverNodeKey,\r\n        dropPosition,\r\n        dropLevelOffset,\r\n        dropTargetKey,\r\n        dropContainerKey,\r\n        dropTargetPos,\r\n        dropAllowed\r\n      });\r\n      if (onDragenter) {\r\n        onDragenter({\r\n          event,\r\n          node: node.eventData,\r\n          expandedKeys: expandedKeys.value\r\n        });\r\n      }\r\n    };\r\n    const onNodeDragOver = (event, node) => {\r\n      const {\r\n        onDragover,\r\n        allowDrop,\r\n        direction\r\n      } = props;\r\n      if (!dragNode) {\r\n        return;\r\n      }\r\n      const {\r\n        dropPosition,\r\n        dropLevelOffset,\r\n        dropTargetKey,\r\n        dropContainerKey,\r\n        dropAllowed,\r\n        dropTargetPos,\r\n        dragOverNodeKey\r\n      } = calcDropPosition(event, dragNode, node, indent.value, dragStartMousePosition, allowDrop, flattenNodes.value, keyEntities.value, expandedKeysSet.value, direction);\r\n      if (dragState.dragChildrenKeys.indexOf(dropTargetKey) !== -1 || !dropAllowed) {\r\n        // don't allow drop inside its children\r\n        // don't allow drop when drop is not allowed caculated by calcDropPosition\r\n        return;\r\n      }\r\n      // Update drag position\r\n      if (dragNode.eventKey === dropTargetKey && dropLevelOffset === 0) {\r\n        if (!(dragState.dropPosition === null && dragState.dropLevelOffset === null && dragState.dropTargetKey === null && dragState.dropContainerKey === null && dragState.dropTargetPos === null && dragState.dropAllowed === false && dragState.dragOverNodeKey === null)) {\r\n          resetDragState();\r\n        }\r\n      } else if (!(dropPosition === dragState.dropPosition && dropLevelOffset === dragState.dropLevelOffset && dropTargetKey === dragState.dropTargetKey && dropContainerKey === dragState.dropContainerKey && dropTargetPos === dragState.dropTargetPos && dropAllowed === dragState.dropAllowed && dragOverNodeKey === dragState.dragOverNodeKey)) {\r\n        _extends(dragState, {\r\n          dropPosition,\r\n          dropLevelOffset,\r\n          dropTargetKey,\r\n          dropContainerKey,\r\n          dropTargetPos,\r\n          dropAllowed,\r\n          dragOverNodeKey\r\n        });\r\n      }\r\n      if (onDragover) {\r\n        onDragover({\r\n          event,\r\n          node: node.eventData\r\n        });\r\n      }\r\n    };\r\n    const onNodeDragLeave = (event, node) => {\r\n      // if it is outside the droppable area\r\n      // currentMouseOverDroppableNodeKey will be updated in dragenter event when into another droppable receiver.\r\n      if (currentMouseOverDroppableNodeKey === node.eventKey && !event.currentTarget.contains(event.relatedTarget)) {\r\n        resetDragState();\r\n        currentMouseOverDroppableNodeKey = null;\r\n      }\r\n      const {\r\n        onDragleave\r\n      } = props;\r\n      if (onDragleave) {\r\n        onDragleave({\r\n          event,\r\n          node: node.eventData\r\n        });\r\n      }\r\n    };\r\n    const onNodeDrop = function (event, _node) {\r\n      let outsideTree = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n      var _a;\r\n      const {\r\n        dragChildrenKeys,\r\n        dropPosition,\r\n        dropTargetKey,\r\n        dropTargetPos,\r\n        dropAllowed\r\n      } = dragState;\r\n      if (!dropAllowed) return;\r\n      const {\r\n        onDrop\r\n      } = props;\r\n      dragState.dragOverNodeKey = null;\r\n      cleanDragState();\r\n      if (dropTargetKey === null) return;\r\n      const abstractDropNodeProps = _extends(_extends({}, getTreeNodeProps(dropTargetKey, toRaw(treeNodeRequiredProps.value))), {\r\n        active: ((_a = activeItem.value) === null || _a === void 0 ? void 0 : _a.key) === dropTargetKey,\r\n        data: keyEntities.value[dropTargetKey].node\r\n      });\r\n      const dropToChild = dragChildrenKeys.indexOf(dropTargetKey) !== -1;\r\n      warning(!dropToChild, \"Can not drop to dragNode's children node. Maybe this is a bug of ant-design-vue. Please report an issue.\");\r\n      const posArr = posToArr(dropTargetPos);\r\n      const dropResult = {\r\n        event,\r\n        node: convertNodePropsToEventData(abstractDropNodeProps),\r\n        dragNode: dragNode ? dragNode.eventData : null,\r\n        dragNodesKeys: [dragNode.eventKey].concat(dragChildrenKeys),\r\n        dropToGap: dropPosition !== 0,\r\n        dropPosition: dropPosition + Number(posArr[posArr.length - 1])\r\n      };\r\n      if (!outsideTree) {\r\n        onDrop === null || onDrop === void 0 ? void 0 : onDrop(dropResult);\r\n      }\r\n      dragNode = null;\r\n    };\r\n    const triggerExpandActionExpand = (e, treeNode) => {\r\n      const {\r\n        expanded,\r\n        key\r\n      } = treeNode;\r\n      const node = flattenNodes.value.filter(nodeItem => nodeItem.key === key)[0];\r\n      const eventNode = convertNodePropsToEventData(_extends(_extends({}, getTreeNodeProps(key, treeNodeRequiredProps.value)), {\r\n        data: node.data\r\n      }));\r\n      setExpandedKeys(expanded ? arrDel(expandedKeys.value, key) : arrAdd(expandedKeys.value, key));\r\n      onNodeExpand(e, eventNode);\r\n    };\r\n    const onNodeClick = (e, treeNode) => {\r\n      const {\r\n        onClick,\r\n        expandAction\r\n      } = props;\r\n      if (expandAction === 'click') {\r\n        triggerExpandActionExpand(e, treeNode);\r\n      }\r\n      if (onClick) {\r\n        onClick(e, treeNode);\r\n      }\r\n    };\r\n    const onNodeDoubleClick = (e, treeNode) => {\r\n      const {\r\n        onDblclick,\r\n        expandAction\r\n      } = props;\r\n      if (expandAction === 'doubleclick' || expandAction === 'dblclick') {\r\n        triggerExpandActionExpand(e, treeNode);\r\n      }\r\n      if (onDblclick) {\r\n        onDblclick(e, treeNode);\r\n      }\r\n    };\r\n    const onNodeSelect = (e, treeNode) => {\r\n      let newSelectedKeys = selectedKeys.value;\r\n      const {\r\n        onSelect,\r\n        multiple\r\n      } = props;\r\n      const {\r\n        selected\r\n      } = treeNode;\r\n      const key = treeNode[fieldNames.value.key];\r\n      const targetSelected = !selected;\r\n      // Update selected keys\r\n      if (!targetSelected) {\r\n        newSelectedKeys = arrDel(newSelectedKeys, key);\r\n      } else if (!multiple) {\r\n        newSelectedKeys = [key];\r\n      } else {\r\n        newSelectedKeys = arrAdd(newSelectedKeys, key);\r\n      }\r\n      // [Legacy] Not found related usage in doc or upper libs\r\n      const keyEntitiesValue = keyEntities.value;\r\n      const selectedNodes = newSelectedKeys.map(selectedKey => {\r\n        const entity = keyEntitiesValue[selectedKey];\r\n        if (!entity) return null;\r\n        return entity.node;\r\n      }).filter(node => node);\r\n      if (props.selectedKeys === undefined) {\r\n        selectedKeys.value = newSelectedKeys;\r\n      }\r\n      if (onSelect) {\r\n        onSelect(newSelectedKeys, {\r\n          event: 'select',\r\n          selected: targetSelected,\r\n          node: treeNode,\r\n          selectedNodes,\r\n          nativeEvent: e\r\n        });\r\n      }\r\n    };\r\n    const onNodeCheck = (e, treeNode, checked) => {\r\n      const {\r\n        checkStrictly,\r\n        onCheck\r\n      } = props;\r\n      const key = treeNode[fieldNames.value.key];\r\n      // Prepare trigger arguments\r\n      let checkedObj;\r\n      const eventObj = {\r\n        event: 'check',\r\n        node: treeNode,\r\n        checked,\r\n        nativeEvent: e\r\n      };\r\n      const keyEntitiesValue = keyEntities.value;\r\n      if (checkStrictly) {\r\n        const newCheckedKeys = checked ? arrAdd(checkedKeys.value, key) : arrDel(checkedKeys.value, key);\r\n        const newHalfCheckedKeys = arrDel(halfCheckedKeys.value, key);\r\n        checkedObj = {\r\n          checked: newCheckedKeys,\r\n          halfChecked: newHalfCheckedKeys\r\n        };\r\n        eventObj.checkedNodes = newCheckedKeys.map(checkedKey => keyEntitiesValue[checkedKey]).filter(entity => entity).map(entity => entity.node);\r\n        if (props.checkedKeys === undefined) {\r\n          checkedKeys.value = newCheckedKeys;\r\n        }\r\n      } else {\r\n        // Always fill first\r\n        let {\r\n          checkedKeys: newCheckedKeys,\r\n          halfCheckedKeys: newHalfCheckedKeys\r\n        } = conductCheck([...checkedKeys.value, key], true, keyEntitiesValue, maxLevel.value, levelEntities.value);\r\n        // If remove, we do it again to correction\r\n        if (!checked) {\r\n          const keySet = new Set(newCheckedKeys);\r\n          keySet.delete(key);\r\n          ({\r\n            checkedKeys: newCheckedKeys,\r\n            halfCheckedKeys: newHalfCheckedKeys\r\n          } = conductCheck(Array.from(keySet), {\r\n            checked: false,\r\n            halfCheckedKeys: newHalfCheckedKeys\r\n          }, keyEntitiesValue, maxLevel.value, levelEntities.value));\r\n        }\r\n        checkedObj = newCheckedKeys;\r\n        // [Legacy] This is used for vc-tree-select`\r\n        eventObj.checkedNodes = [];\r\n        eventObj.checkedNodesPositions = [];\r\n        eventObj.halfCheckedKeys = newHalfCheckedKeys;\r\n        newCheckedKeys.forEach(checkedKey => {\r\n          const entity = keyEntitiesValue[checkedKey];\r\n          if (!entity) return;\r\n          const {\r\n            node,\r\n            pos\r\n          } = entity;\r\n          eventObj.checkedNodes.push(node);\r\n          eventObj.checkedNodesPositions.push({\r\n            node,\r\n            pos\r\n          });\r\n        });\r\n        if (props.checkedKeys === undefined) {\r\n          checkedKeys.value = newCheckedKeys;\r\n          halfCheckedKeys.value = newHalfCheckedKeys;\r\n        }\r\n      }\r\n      if (onCheck) {\r\n        onCheck(checkedObj, eventObj);\r\n      }\r\n    };\r\n    const onNodeLoad = treeNode => {\r\n      const key = treeNode[fieldNames.value.key];\r\n      const loadPromise = new Promise((resolve, reject) => {\r\n        // We need to get the latest state of loading/loaded keys\r\n        const {\r\n          loadData,\r\n          onLoad\r\n        } = props;\r\n        if (!loadData || loadedKeysSet.value.has(key) || loadingKeysSet.value.has(key)) {\r\n          return null;\r\n        }\r\n        // Process load data\r\n        const promise = loadData(treeNode);\r\n        promise.then(() => {\r\n          const newLoadedKeys = arrAdd(loadedKeys.value, key);\r\n          const newLoadingKeys = arrDel(loadingKeys.value, key);\r\n          // onLoad should trigger before internal setState to avoid `loadData` trigger twice.\r\n          // https://github.com/ant-design/ant-design/issues/12464\r\n          if (onLoad) {\r\n            onLoad(newLoadedKeys, {\r\n              event: 'load',\r\n              node: treeNode\r\n            });\r\n          }\r\n          if (props.loadedKeys === undefined) {\r\n            loadedKeys.value = newLoadedKeys;\r\n          }\r\n          loadingKeys.value = newLoadingKeys;\r\n          resolve();\r\n        }).catch(e => {\r\n          const newLoadingKeys = arrDel(loadingKeys.value, key);\r\n          loadingKeys.value = newLoadingKeys;\r\n          // If exceed max retry times, we give up retry\r\n          loadingRetryTimes[key] = (loadingRetryTimes[key] || 0) + 1;\r\n          if (loadingRetryTimes[key] >= MAX_RETRY_TIMES) {\r\n            warning(false, 'Retry for `loadData` many times but still failed. No more retry.');\r\n            const newLoadedKeys = arrAdd(loadedKeys.value, key);\r\n            if (props.loadedKeys === undefined) {\r\n              loadedKeys.value = newLoadedKeys;\r\n            }\r\n            resolve();\r\n          }\r\n          reject(e);\r\n        });\r\n        loadingKeys.value = arrAdd(loadingKeys.value, key);\r\n      });\r\n      // Not care warning if we ignore this\r\n      loadPromise.catch(() => {});\r\n      return loadPromise;\r\n    };\r\n    const onNodeMouseEnter = (event, node) => {\r\n      const {\r\n        onMouseenter\r\n      } = props;\r\n      if (onMouseenter) {\r\n        onMouseenter({\r\n          event,\r\n          node\r\n        });\r\n      }\r\n    };\r\n    const onNodeMouseLeave = (event, node) => {\r\n      const {\r\n        onMouseleave\r\n      } = props;\r\n      if (onMouseleave) {\r\n        onMouseleave({\r\n          event,\r\n          node\r\n        });\r\n      }\r\n    };\r\n    const onNodeContextMenu = (event, node) => {\r\n      const {\r\n        onRightClick\r\n      } = props;\r\n      if (onRightClick) {\r\n        event.preventDefault();\r\n        onRightClick({\r\n          event,\r\n          node\r\n        });\r\n      }\r\n    };\r\n    const onFocus = e => {\r\n      const {\r\n        onFocus\r\n      } = props;\r\n      focused.value = true;\r\n      if (onFocus) {\r\n        onFocus(e);\r\n      }\r\n    };\r\n    const onBlur = e => {\r\n      const {\r\n        onBlur\r\n      } = props;\r\n      focused.value = false;\r\n      onActiveChange(null);\r\n      if (onBlur) {\r\n        onBlur(e);\r\n      }\r\n    };\r\n    const onNodeExpand = (e, treeNode) => {\r\n      let newExpandedKeys = expandedKeys.value;\r\n      const {\r\n        onExpand,\r\n        loadData\r\n      } = props;\r\n      const {\r\n        expanded\r\n      } = treeNode;\r\n      const key = treeNode[fieldNames.value.key];\r\n      // Do nothing when motion is in progress\r\n      if (listChanging.value) {\r\n        return;\r\n      }\r\n      // Update selected keys\r\n      const index = newExpandedKeys.indexOf(key);\r\n      const targetExpanded = !expanded;\r\n      warning(expanded && index !== -1 || !expanded && index === -1, 'Expand state not sync with index check');\r\n      if (targetExpanded) {\r\n        newExpandedKeys = arrAdd(newExpandedKeys, key);\r\n      } else {\r\n        newExpandedKeys = arrDel(newExpandedKeys, key);\r\n      }\r\n      setExpandedKeys(newExpandedKeys);\r\n      if (onExpand) {\r\n        onExpand(newExpandedKeys, {\r\n          node: treeNode,\r\n          expanded: targetExpanded,\r\n          nativeEvent: e\r\n        });\r\n      }\r\n      // Async Load data\r\n      if (targetExpanded && loadData) {\r\n        const loadPromise = onNodeLoad(treeNode);\r\n        if (loadPromise) {\r\n          loadPromise.then(() => {\r\n            // [Legacy] Refresh logic\r\n            // const newFlattenTreeData = flattenTreeData(\r\n            //   treeData.value,\r\n            //   newExpandedKeys,\r\n            //   fieldNames.value,\r\n            // );\r\n            // flattenNodes.value = newFlattenTreeData;\r\n          }).catch(e => {\r\n            const expandedKeysToRestore = arrDel(expandedKeys.value, key);\r\n            setExpandedKeys(expandedKeysToRestore);\r\n            Promise.reject(e);\r\n          });\r\n        }\r\n      }\r\n    };\r\n    const onListChangeStart = () => {\r\n      listChanging.value = true;\r\n    };\r\n    const onListChangeEnd = () => {\r\n      setTimeout(() => {\r\n        listChanging.value = false;\r\n      });\r\n    };\r\n    // =========================== Keyboard ===========================\r\n    const onActiveChange = newActiveKey => {\r\n      const {\r\n        onActiveChange\r\n      } = props;\r\n      if (activeKey.value === newActiveKey) {\r\n        return;\r\n      }\r\n      if (props.activeKey !== undefined) {\r\n        activeKey.value = newActiveKey;\r\n      }\r\n      if (newActiveKey !== null) {\r\n        scrollTo({\r\n          key: newActiveKey\r\n        });\r\n      }\r\n      if (onActiveChange) {\r\n        onActiveChange(newActiveKey);\r\n      }\r\n    };\r\n    const activeItem = computed(() => {\r\n      if (activeKey.value === null) {\r\n        return null;\r\n      }\r\n      return flattenNodes.value.find(_ref4 => {\r\n        let {\r\n          key\r\n        } = _ref4;\r\n        return key === activeKey.value;\r\n      }) || null;\r\n    });\r\n    const offsetActiveKey = offset => {\r\n      let index = flattenNodes.value.findIndex(_ref5 => {\r\n        let {\r\n          key\r\n        } = _ref5;\r\n        return key === activeKey.value;\r\n      });\r\n      // Align with index\r\n      if (index === -1 && offset < 0) {\r\n        index = flattenNodes.value.length;\r\n      }\r\n      index = (index + offset + flattenNodes.value.length) % flattenNodes.value.length;\r\n      const item = flattenNodes.value[index];\r\n      if (item) {\r\n        const {\r\n          key\r\n        } = item;\r\n        onActiveChange(key);\r\n      } else {\r\n        onActiveChange(null);\r\n      }\r\n    };\r\n    const activeItemEventNode = computed(() => {\r\n      return convertNodePropsToEventData(_extends(_extends({}, getTreeNodeProps(activeKey.value, treeNodeRequiredProps.value)), {\r\n        data: activeItem.value.data,\r\n        active: true\r\n      }));\r\n    });\r\n    const onKeydown = event => {\r\n      const {\r\n        onKeydown,\r\n        checkable,\r\n        selectable\r\n      } = props;\r\n      // >>>>>>>>>> Direction\r\n      switch (event.which) {\r\n        case KeyCode.UP:\r\n          {\r\n            offsetActiveKey(-1);\r\n            event.preventDefault();\r\n            break;\r\n          }\r\n        case KeyCode.DOWN:\r\n          {\r\n            offsetActiveKey(1);\r\n            event.preventDefault();\r\n            break;\r\n          }\r\n      }\r\n      // >>>>>>>>>> Expand & Selection\r\n      const item = activeItem.value;\r\n      if (item && item.data) {\r\n        const expandable = item.data.isLeaf === false || !!(item.data.children || []).length;\r\n        const eventNode = activeItemEventNode.value;\r\n        switch (event.which) {\r\n          // >>> Expand\r\n          case KeyCode.LEFT:\r\n            {\r\n              // Collapse if possible\r\n              if (expandable && expandedKeysSet.value.has(activeKey.value)) {\r\n                onNodeExpand({}, eventNode);\r\n              } else if (item.parent) {\r\n                onActiveChange(item.parent.key);\r\n              }\r\n              event.preventDefault();\r\n              break;\r\n            }\r\n          case KeyCode.RIGHT:\r\n            {\r\n              // Expand if possible\r\n              if (expandable && !expandedKeysSet.value.has(activeKey.value)) {\r\n                onNodeExpand({}, eventNode);\r\n              } else if (item.children && item.children.length) {\r\n                onActiveChange(item.children[0].key);\r\n              }\r\n              event.preventDefault();\r\n              break;\r\n            }\r\n          // Selection\r\n          case KeyCode.ENTER:\r\n          case KeyCode.SPACE:\r\n            {\r\n              if (checkable && !eventNode.disabled && eventNode.checkable !== false && !eventNode.disableCheckbox) {\r\n                onNodeCheck({}, eventNode, !checkedKeysSet.value.has(activeKey.value));\r\n              } else if (!checkable && selectable && !eventNode.disabled && eventNode.selectable !== false) {\r\n                onNodeSelect({}, eventNode);\r\n              }\r\n              break;\r\n            }\r\n        }\r\n      }\r\n      if (onKeydown) {\r\n        onKeydown(event);\r\n      }\r\n    };\r\n    expose({\r\n      onNodeExpand,\r\n      scrollTo,\r\n      onKeydown,\r\n      selectedKeys: computed(() => selectedKeys.value),\r\n      checkedKeys: computed(() => checkedKeys.value),\r\n      halfCheckedKeys: computed(() => halfCheckedKeys.value),\r\n      loadedKeys: computed(() => loadedKeys.value),\r\n      loadingKeys: computed(() => loadingKeys.value),\r\n      expandedKeys: computed(() => expandedKeys.value)\r\n    });\r\n    onUnmounted(() => {\r\n      window.removeEventListener('dragend', onWindowDragEnd);\r\n      destroyed.value = true;\r\n    });\r\n    useProvideKeysState({\r\n      expandedKeys,\r\n      selectedKeys,\r\n      loadedKeys,\r\n      loadingKeys,\r\n      checkedKeys,\r\n      halfCheckedKeys,\r\n      expandedKeysSet,\r\n      selectedKeysSet,\r\n      loadedKeysSet,\r\n      loadingKeysSet,\r\n      checkedKeysSet,\r\n      halfCheckedKeysSet,\r\n      flattenNodes\r\n    });\r\n    return () => {\r\n      const {\r\n        // focused,\r\n        // flattenNodes,\r\n        // keyEntities,\r\n        draggingNodeKey,\r\n        // activeKey,\r\n        dropLevelOffset,\r\n        dropContainerKey,\r\n        dropTargetKey,\r\n        dropPosition,\r\n        dragOverNodeKey\r\n        // indent,\r\n      } = dragState;\r\n      const {\r\n        prefixCls,\r\n        showLine,\r\n        focusable,\r\n        tabindex = 0,\r\n        selectable,\r\n        showIcon,\r\n        icon = slots.icon,\r\n        switcherIcon,\r\n        draggable,\r\n        checkable,\r\n        checkStrictly,\r\n        disabled,\r\n        motion,\r\n        loadData,\r\n        filterTreeNode,\r\n        height,\r\n        itemHeight,\r\n        virtual,\r\n        dropIndicatorRender,\r\n        onContextmenu,\r\n        onScroll,\r\n        direction,\r\n        rootClassName,\r\n        rootStyle\r\n      } = props;\r\n      const {\r\n        class: className,\r\n        style\r\n      } = attrs;\r\n      const domProps = pickAttrs(_extends(_extends({}, props), attrs), {\r\n        aria: true,\r\n        data: true\r\n      });\r\n      // It's better move to hooks but we just simply keep here\r\n      let draggableConfig;\r\n      if (draggable) {\r\n        if (typeof draggable === 'object') {\r\n          draggableConfig = draggable;\r\n        } else if (typeof draggable === 'function') {\r\n          draggableConfig = {\r\n            nodeDraggable: draggable\r\n          };\r\n        } else {\r\n          draggableConfig = {};\r\n        }\r\n      } else {\r\n        draggableConfig = false;\r\n      }\r\n      return _createVNode(TreeContext, {\r\n        \"value\": {\r\n          prefixCls,\r\n          selectable,\r\n          showIcon,\r\n          icon,\r\n          switcherIcon,\r\n          draggable: draggableConfig,\r\n          draggingNodeKey,\r\n          checkable,\r\n          customCheckable: slots.checkable,\r\n          checkStrictly,\r\n          disabled,\r\n          keyEntities: keyEntities.value,\r\n          dropLevelOffset,\r\n          dropContainerKey,\r\n          dropTargetKey,\r\n          dropPosition,\r\n          dragOverNodeKey,\r\n          dragging: draggingNodeKey !== null,\r\n          indent: indent.value,\r\n          direction,\r\n          dropIndicatorRender,\r\n          loadData,\r\n          filterTreeNode,\r\n          onNodeClick,\r\n          onNodeDoubleClick,\r\n          onNodeExpand,\r\n          onNodeSelect,\r\n          onNodeCheck,\r\n          onNodeLoad,\r\n          onNodeMouseEnter,\r\n          onNodeMouseLeave,\r\n          onNodeContextMenu,\r\n          onNodeDragStart,\r\n          onNodeDragEnter,\r\n          onNodeDragOver,\r\n          onNodeDragLeave,\r\n          onNodeDragEnd,\r\n          onNodeDrop,\r\n          slots\r\n        }\r\n      }, {\r\n        default: () => [_createVNode(\"div\", {\r\n          \"role\": \"tree\",\r\n          \"class\": classNames(prefixCls, className, rootClassName, {\r\n            [`${prefixCls}-show-line`]: showLine,\r\n            [`${prefixCls}-focused`]: focused.value,\r\n            [`${prefixCls}-active-focused`]: activeKey.value !== null\r\n          }),\r\n          \"style\": rootStyle\r\n        }, [_createVNode(NodeList, _objectSpread({\r\n          \"ref\": listRef,\r\n          \"prefixCls\": prefixCls,\r\n          \"style\": style,\r\n          \"disabled\": disabled,\r\n          \"selectable\": selectable,\r\n          \"checkable\": !!checkable,\r\n          \"motion\": motion,\r\n          \"height\": height,\r\n          \"itemHeight\": itemHeight,\r\n          \"virtual\": virtual,\r\n          \"focusable\": focusable,\r\n          \"focused\": focused.value,\r\n          \"tabindex\": tabindex,\r\n          \"activeItem\": activeItem.value,\r\n          \"onFocus\": onFocus,\r\n          \"onBlur\": onBlur,\r\n          \"onKeydown\": onKeydown,\r\n          \"onActiveChange\": onActiveChange,\r\n          \"onListChangeStart\": onListChangeStart,\r\n          \"onListChangeEnd\": onListChangeEnd,\r\n          \"onContextmenu\": onContextmenu,\r\n          \"onScroll\": onScroll\r\n        }, domProps), null)])]\r\n      });\r\n    };\r\n  }\r\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}