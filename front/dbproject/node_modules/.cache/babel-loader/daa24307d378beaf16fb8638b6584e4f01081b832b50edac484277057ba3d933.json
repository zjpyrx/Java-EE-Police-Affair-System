{"ast":null,"code":"import { toRaw, shallowRef, watchEffect, watch } from 'vue';\nimport { convertChildrenToData } from '../utils/legacyUtil';\n/**\r\n * Parse `children` to `options` if `options` is not provided.\r\n * Then flatten the `options`.\r\n */\nexport default function useOptions(options, children, fieldNames) {\n  const mergedOptions = shallowRef();\n  const valueOptions = shallowRef();\n  const labelOptions = shallowRef();\n  const tempMergedOptions = shallowRef([]);\n  watch([options, children], () => {\n    if (options.value) {\n      tempMergedOptions.value = toRaw(options.value).slice();\n    } else {\n      tempMergedOptions.value = convertChildrenToData(children.value);\n    }\n  }, {\n    immediate: true,\n    deep: true\n  });\n  watchEffect(() => {\n    const newOptions = tempMergedOptions.value;\n    const newValueOptions = new Map();\n    const newLabelOptions = new Map();\n    const fieldNamesValue = fieldNames.value;\n    function dig(optionList) {\n      let isChildren = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      // for loop to speed up collection speed\n      for (let i = 0; i < optionList.length; i += 1) {\n        const option = optionList[i];\n        if (!option[fieldNamesValue.options] || isChildren) {\n          newValueOptions.set(option[fieldNamesValue.value], option);\n          newLabelOptions.set(option[fieldNamesValue.label], option);\n        } else {\n          dig(option[fieldNamesValue.options], true);\n        }\n      }\n    }\n    dig(newOptions);\n    mergedOptions.value = newOptions;\n    valueOptions.value = newValueOptions;\n    labelOptions.value = newLabelOptions;\n  });\n  return {\n    options: mergedOptions,\n    valueOptions,\n    labelOptions\n  };\n}","map":{"version":3,"names":["toRaw","shallowRef","watchEffect","watch","convertChildrenToData","useOptions","options","children","fieldNames","mergedOptions","valueOptions","labelOptions","tempMergedOptions","value","slice","immediate","deep","newOptions","newValueOptions","Map","newLabelOptions","fieldNamesValue","dig","optionList","isChildren","arguments","length","undefined","i","option","set","label"],"sources":["C:/GitHubWarehouse/2023-TJU-DBD-Police-Affair-System/My-front/dbproject/node_modules/ant-design-vue/es/vc-select/hooks/useOptions.js"],"sourcesContent":["import { toRaw, shallowRef, watchEffect, watch } from 'vue';\r\nimport { convertChildrenToData } from '../utils/legacyUtil';\r\n/**\r\n * Parse `children` to `options` if `options` is not provided.\r\n * Then flatten the `options`.\r\n */\r\nexport default function useOptions(options, children, fieldNames) {\r\n  const mergedOptions = shallowRef();\r\n  const valueOptions = shallowRef();\r\n  const labelOptions = shallowRef();\r\n  const tempMergedOptions = shallowRef([]);\r\n  watch([options, children], () => {\r\n    if (options.value) {\r\n      tempMergedOptions.value = toRaw(options.value).slice();\r\n    } else {\r\n      tempMergedOptions.value = convertChildrenToData(children.value);\r\n    }\r\n  }, {\r\n    immediate: true,\r\n    deep: true\r\n  });\r\n  watchEffect(() => {\r\n    const newOptions = tempMergedOptions.value;\r\n    const newValueOptions = new Map();\r\n    const newLabelOptions = new Map();\r\n    const fieldNamesValue = fieldNames.value;\r\n    function dig(optionList) {\r\n      let isChildren = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\r\n      // for loop to speed up collection speed\r\n      for (let i = 0; i < optionList.length; i += 1) {\r\n        const option = optionList[i];\r\n        if (!option[fieldNamesValue.options] || isChildren) {\r\n          newValueOptions.set(option[fieldNamesValue.value], option);\r\n          newLabelOptions.set(option[fieldNamesValue.label], option);\r\n        } else {\r\n          dig(option[fieldNamesValue.options], true);\r\n        }\r\n      }\r\n    }\r\n    dig(newOptions);\r\n    mergedOptions.value = newOptions;\r\n    valueOptions.value = newValueOptions;\r\n    labelOptions.value = newLabelOptions;\r\n  });\r\n  return {\r\n    options: mergedOptions,\r\n    valueOptions,\r\n    labelOptions\r\n  };\r\n}"],"mappings":"AAAA,SAASA,KAAK,EAAEC,UAAU,EAAEC,WAAW,EAAEC,KAAK,QAAQ,KAAK;AAC3D,SAASC,qBAAqB,QAAQ,qBAAqB;AAC3D;AACA;AACA;AACA;AACA,eAAe,SAASC,UAAUA,CAACC,OAAO,EAAEC,QAAQ,EAAEC,UAAU,EAAE;EAChE,MAAMC,aAAa,GAAGR,UAAU,CAAC,CAAC;EAClC,MAAMS,YAAY,GAAGT,UAAU,CAAC,CAAC;EACjC,MAAMU,YAAY,GAAGV,UAAU,CAAC,CAAC;EACjC,MAAMW,iBAAiB,GAAGX,UAAU,CAAC,EAAE,CAAC;EACxCE,KAAK,CAAC,CAACG,OAAO,EAAEC,QAAQ,CAAC,EAAE,MAAM;IAC/B,IAAID,OAAO,CAACO,KAAK,EAAE;MACjBD,iBAAiB,CAACC,KAAK,GAAGb,KAAK,CAACM,OAAO,CAACO,KAAK,CAAC,CAACC,KAAK,CAAC,CAAC;IACxD,CAAC,MAAM;MACLF,iBAAiB,CAACC,KAAK,GAAGT,qBAAqB,CAACG,QAAQ,CAACM,KAAK,CAAC;IACjE;EACF,CAAC,EAAE;IACDE,SAAS,EAAE,IAAI;IACfC,IAAI,EAAE;EACR,CAAC,CAAC;EACFd,WAAW,CAAC,MAAM;IAChB,MAAMe,UAAU,GAAGL,iBAAiB,CAACC,KAAK;IAC1C,MAAMK,eAAe,GAAG,IAAIC,GAAG,CAAC,CAAC;IACjC,MAAMC,eAAe,GAAG,IAAID,GAAG,CAAC,CAAC;IACjC,MAAME,eAAe,GAAGb,UAAU,CAACK,KAAK;IACxC,SAASS,GAAGA,CAACC,UAAU,EAAE;MACvB,IAAIC,UAAU,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,KAAK;MAC1F;MACA,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,UAAU,CAACG,MAAM,EAAEE,CAAC,IAAI,CAAC,EAAE;QAC7C,MAAMC,MAAM,GAAGN,UAAU,CAACK,CAAC,CAAC;QAC5B,IAAI,CAACC,MAAM,CAACR,eAAe,CAACf,OAAO,CAAC,IAAIkB,UAAU,EAAE;UAClDN,eAAe,CAACY,GAAG,CAACD,MAAM,CAACR,eAAe,CAACR,KAAK,CAAC,EAAEgB,MAAM,CAAC;UAC1DT,eAAe,CAACU,GAAG,CAACD,MAAM,CAACR,eAAe,CAACU,KAAK,CAAC,EAAEF,MAAM,CAAC;QAC5D,CAAC,MAAM;UACLP,GAAG,CAACO,MAAM,CAACR,eAAe,CAACf,OAAO,CAAC,EAAE,IAAI,CAAC;QAC5C;MACF;IACF;IACAgB,GAAG,CAACL,UAAU,CAAC;IACfR,aAAa,CAACI,KAAK,GAAGI,UAAU;IAChCP,YAAY,CAACG,KAAK,GAAGK,eAAe;IACpCP,YAAY,CAACE,KAAK,GAAGO,eAAe;EACtC,CAAC,CAAC;EACF,OAAO;IACLd,OAAO,EAAEG,aAAa;IACtBC,YAAY;IACZC;EACF,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}